From 287dbf7e38850ed1e4a7e1c720a111dee0cc77d9 Mon Sep 17 00:00:00 2001
From: Simone Dalmasso <simone.dalmasso@gmail.com>
Date: Tue, 1 Dec 2015 17:40:06 +0100
Subject: [PATCH] use WCS version 2.0.1, no need to do getCapabilities

---
 geonode/geoserver/ows.py     | 71 +++++++++++---------------------------------
 geonode/geoserver/signals.py | 55 +++++++++-------------------------
 geonode/settings.py          |  2 ++
 3 files changed, 33 insertions(+), 95 deletions(-)

diff --git a/geonode/geoserver/ows.py b/geonode/geoserver/ows.py
index 83bfcd1..cd562a7 100644
--- a/geonode/geoserver/ows.py
+++ b/geonode/geoserver/ows.py
@@ -20,69 +20,32 @@
 import logging
 
 from django.utils.translation import ugettext_lazy as _
-from owslib.wcs import WebCoverageService
-from owslib.coverage.wcsBase import ServiceException
 import urllib
-from geonode import GeoNodeException
-from re import sub
 
 logger = logging.getLogger(__name__)
 
 DEFAULT_EXCLUDE_FORMATS = ['PNG', 'JPEG', 'GIF', 'TIFF']
 
 
-def wcs_links(
-        wcs_url,
-        identifier,
-        bbox=None,
-        crs=None,
-        height=None,
-        width=None,
-        exclude_formats=True,
-        quiet=True,
-        version='1.0.0'):
-    # FIXME(Ariel): This would only work for layers marked for public view,
-    # what about the ones with permissions enabled?
-
-    try:
-        wcs = WebCoverageService(wcs_url, version=version)
-    except ServiceException as err:
-        err_msg = 'WCS server returned exception: %s' % err
-        if not quiet:
-            logger.warn(err_msg)
-        raise GeoNodeException(err_msg)
-
-    msg = ('Could not create WCS links for layer "%s",'
-           ' it was not in the WCS catalog,'
-           ' the available layers were: "%s"' % (
-               identifier, wcs.contents.keys()))
+def _wcs_link(wcs_url, identifier, mime):
+    return wcs_url + urllib.urlencode({
+        'service': 'WCS',
+        'request': 'GetCoverage',
+        'coverageid': identifier,
+        'format': mime,
+        'version': '2.0.1'
+    })
 
+
+def wcs_links(wcs_url, identifier):
+    types = [
+        ("x-gzip", _("GZIP"), "application/x-gzip"),
+        ("geotiff", _("GeoTIFF"), "image/tiff"),
+    ]
     output = []
-    formats = []
-
-    if identifier not in wcs.contents:
-        if not quiet:
-            raise RuntimeError(msg)
-        else:
-            logger.warn(msg)
-    else:
-        coverage = wcs.contents[identifier]
-        formats = coverage.supportedFormats
-        for f in formats:
-            if exclude_formats and f in DEFAULT_EXCLUDE_FORMATS:
-                continue
-            # roundabout, hacky way to accomplish getting a getCoverage url.
-            # nonetheless, it's better than having to load an entire large
-            # coverage just to generate a URL
-            fakeUrl = wcs.getCoverage(identifier=coverage.id, format=f,
-                                      bbox=bbox, crs=crs, height=20,
-                                      width=20).geturl()
-            url = sub(r'(height=)20(\&width=)20', r'\g<1>{0}\g<2>{1}',
-                      fakeUrl).format(height, width)
-            # The outputs are: (ext, name, mime, url)
-            # FIXME(Ariel): Find a way to get proper ext, name and mime
-            # using format as a default for all is not good enough
-            output.append((f, f, f, url))
+    for ext, name, mime in types:
+        url = _wcs_link(wcs_url, identifier, mime)
+        output.append((ext, name, mime, url))
     return output
 
 
diff --git a/geonode/geoserver/signals.py b/geonode/geoserver/signals.py
index e873850..6e71a0e 100644
--- a/geonode/geoserver/signals.py
+++ b/geonode/geoserver/signals.py
@@ -6,13 +6,12 @@
 from urlparse import urlparse, urljoin
 from socket import error as socket_error
 
-from django.utils.translation import ugettext, ugettext_lazy as _
+from django.utils.translation import ugettext
 from django.conf import settings
 
-from geonode import GeoNodeException
 from geonode.geoserver.ows import wcs_links, wfs_links, wms_links
 from geonode.geoserver.helpers import cascading_delete, set_attributes
-from geonode.geoserver.helpers import set_styles, gs_catalog, get_coverage_grid_extent
+from geonode.geoserver.helpers import set_styles, gs_catalog
 from geonode.geoserver.helpers import ogc_server_settings
 from geonode.geoserver.helpers import geoserver_upload, http_client
 from geonode.base.models import ResourceBase
@@ -278,46 +277,20 @@ def command_url(command):
                                        )
 
     elif instance.storeType == 'coverageStore':
-        # FIXME(Ariel): This works for public layers, does it work for restricted too?
-        # would those end up with no geotiff links, like, forever?
-        permissions = instance.get_all_level_info()
 
-        instance.set_permissions(
-            {'users': {'AnonymousUser': ['view_resourcebase']}})
+        links = wcs_links(ogc_server_settings.public_url + 'wcs?',
+                          instance.typename.encode('utf-8'))
 
-        try:
-            # Potentially 3 dimensions can be returned by the grid if there is a z
-            # axis.  Since we only want width/height, slice to the second
-            # dimension
-            covWidth, covHeight = get_coverage_grid_extent(instance)[:2]
-        except GeoNodeException as e:
-            msg = _('Could not create a download link for layer.')
-            try:
-                # HACK: The logger on signals throws an exception
-                logger.warn(msg, e)
-            except:
-                pass
-        else:
-
-            links = wcs_links(ogc_server_settings.public_url + 'wcs?',
-                              instance.typename.encode('utf-8'),
-                              bbox=gs_resource.native_bbox[:-1],
-                              crs=gs_resource.native_bbox[-1],
-                              height=str(covHeight),
-                              width=str(covWidth))
-
-            for ext, name, mime, wcs_url in links:
-                Link.objects.get_or_create(resource=instance.resourcebase_ptr,
-                                           url=wcs_url,
-                                           defaults=dict(
-                                               extension=ext,
-                                               name=name,
-                                               mime=mime,
-                                               link_type='data',
-                                           )
-                                           )
-
-        instance.set_permissions(permissions)
+    for ext, name, mime, wcs_url in links:
+        Link.objects.get_or_create(resource=instance.resourcebase_ptr,
+                                   url=wcs_url,
+                                   defaults=dict(
+                                       extension=ext,
+                                       name=name,
+                                       mime=mime,
+                                       link_type='data',
+                                   )
+                                   )
 
     kml_reflector_link_download = ogc_server_settings.public_url + "wms/kml?" + \
         urllib.urlencode({'layers': instance.typename.encode('utf-8'), 'mode': "download"})
diff --git a/geonode/settings.py b/geonode/settings.py
index bbced0e..25c2880 100644
--- a/geonode/settings.py
+++ b/geonode/settings.py
@@ -745,6 +745,8 @@
     'KML',
     'View in Google Earth',
     'Tiles',
+    'GML',
+    'GZIP'
 ]
 
 ACCOUNT_NOTIFY_ON_PASSWORD_CHANGE = False
